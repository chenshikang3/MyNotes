# 第5章 初始化与清理

## 5.1 初始化

### 5.1.1 构造器

- *（调用构造器）*Java会在用户有能力操作对象之前自动调用相应的构造器，**在创建对象（new）时，将会为对象分配存储空间，并调用相应的构造器**。在Java中，“初始化”和“创建”捆绑在一起，不能分离；
- 如果你写的类中没有构造器，编译器会帮你自动创建一个**无参构造器**；但是如果你已经定义了一个构造器，编译器就不会帮你自动创建。因此如果你已经定义了一个有参数的构造器，还需要一个无参构造器，则需要手动创建；

### 5.1.2 方法重载

- 任何程序设计语言都具备的一项重要的特性就是对名字的运用，通过使用名字你可以引用所有对象和方法；
- 每个重载的方法都必须有一个独一无二的参数类型列表，顺序不同亦可以区分；
- 当传入参数与定义的方法参数列表不匹配时，传入小的参数可以**自动**升级为大的，传入大的参数就需要**手动**强转为小的；
- 以返回值区分重载方法行不通；

### 5.1.3 this

- 在对象调用方法的时候，编译器**暗自**把“所操作对象的引用”作为第一个参数传递给方法，例如：a.peel(1) -> Banana.peel(a, 1);
- this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用；
- **人们期望只在必要处使用this，遵循一种一致而直观的编程风格能节省时间和金钱；**
- **在构造器中调用构造器：this（arg）**，除构造器之外，编译器禁止在其他任何方法中调用构造器；
- 尽管this可以调用一个构造器，但却不能调用两个，此外，**必须将构造器调用置于最起始处**（方法的首行）；

### 5.1.4 static

- static方法就是没有this的方法， 它很像全局方法；
- 要是代码中出现了大量的static方法，就该重新考虑自己的设计了；

### 5.1.5 初始化顺序

- **变量初始化优先于任何方法的调用，及时变量定义散布于方法定义之间**；
- 静态数据都只占一份存储区域；
- 静态初始化只有在必要时刻才会进行，此后，静态对象不会再次被初始化；

- **初始化顺序：先静态对象，而后是非静态对象；**
- 要执行main方法，必须加装main所在的类，从而加载该类中的静态域，从而导致这些静态域对应的类被加载；
- 即使没有显式的使用static关键字，**构造器实际上也是静态方法**；
- 静态初始化只在class对象首次加载的时候进行一次；
- ***静态域在加载类的时候初始化（没有new，直接用类名调用），非静态域在new的时候初始化，new会调用构造方法，没有使用new不会调用构造方法；***

### 5.1.6 数组初始化

- 数组初始化的一种**特殊方式**：用一对花括号括起来，这种情况下**存储空间的分配由编译器负责**；

- **数组初始化**使用new关键字，new的参数可以接受**变量**；

- 数组元素中的基本数据类型值会自动初始化为空值；

- 使用数组支持可变参数列表，可变参数列表不依赖于自动包装机制，而实际上使用的是基本类型；

  ```
  static void printArray(Object[] args){}
  static void printArray(Object... args){}
  支持数组、单个参数、0个参数
  ```

### 5.1.7 枚举类型

- 由于枚举类型的实例是常量，因此按照命名惯例它们都用**大写字母**表示，如果一个名字中有多个单词，用**下划线**分隔；

  ```
  public enum Spiciness {
  	NOT, MILD, MEDIUM
  }
  ordinal():表示某个特定enum常量的声明顺序;
  static values():按顺序，产生一个由这些常量构成的数组;
  ```

- enum有个特别实用的特性，就是可以在switch中使用；

## 5.2 垃圾回收

### 5.2.1 垃圾回收与finalize()

- 垃圾回收器只知道释放那些经由new分配的内存；
- Java允许在类中定义一个名为finalize()的方法，一旦垃圾回收器准备好释放对象所占用的内存时，将首先调用其finalize()方法；
- 1）对象可能不被垃圾回收；2）垃圾回收并不等于“析构”；3）垃圾回收只与内存有关；
- 使用垃圾回收器的唯一原因是为了回收程序不再使用的内存，如果JVM并没有面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的；
- finalize()的需求限制到了一种特殊的情况：通过某种创建对象以外的方式为对象分配了存储空间；
- finalize()可以用来验证终结条件；

### 5.2.2 垃圾回收的工作原理

- 垃圾回收器对于提高对象的创建速度具有明显的效果；
- Java的“堆指针”只是简单地移动到尚未分配的区域；
- 垃圾回收器工作时，一面回收空间，一面使堆中的对象紧凑排列，通过对对象重新排列，实现了一种高速的、有无限空间可分配的堆模型；
- 引用计数：当发现某个对象的引用计数为0时，就释放其占用的空间，缺陷在于，循环引用；
- **垃圾回收器的思想**：从堆栈和静态存储区域开始，遍历所有的引用，找到所有“活“的对象；
- stop-and-copy：将所有存活的对象从当前堆复制到另一个堆，没有复制的全部都是垃圾。当对象复制完之后又紧凑排列了，对象移动时，所有指向它的那些引用都必须修正；
- mark-and-sweep：当只产生少量垃圾甚至不产生垃圾时速度很快，每找到一个活的对象，就会给对象设一个标记，清理过程中，没有标记的对象将被释放，需要重新整理剩下的对象；
- 垃圾回收动作发生的同时，程序将会被暂停；
- JVM中，内存分配以较大的“块”为单位，每个块都有相应的代数，如果块在某处被引用，其代数会增加。大型对象不会被复制（只是其代数会增加），内含小型对象的那些块则被复制并整理；
- “自适应技术”：在回收效率低时，切换到“标记-清扫”模式，并跟踪，当出现很多碎片时，切换回“停止-复制”模式；

---

# 第6章 访问权限控制

- 如果你把代码放到了一个位置，过了一会儿后，发现有更好的方式去实现相同的功能，这正是重构的原动力之一，**重构即重写代码，以使它更可读，更易理解，并因此而更具可维护性；**
- 但是客户端程序员由于要使用你的代码，因此需要你的代码在某些方面保持不变。你想改变代码，他们却想代码不变，就产生了一个**面向对象设计中的一个基本问题“如何把变动的事物与保持不变的事物区分开来。”**；
- 为了解决这一问题，Java提供了**访问权限修饰词**，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的，权限由大到小依次为：public、protected、包访问权限（没有关键词）、private；

## 6.1 包

- 包内含有一组类，它们在单一的**名字空间**之下被组织在一起；
- import导入，提供一个管理名字空间的机制，**所有类成员的名称都是彼此隔离的**；
- 一个.java文件只能有一个public类，**其他额外的类在包之外的世界是无法看见的**；
- Java的可运行程序是一组可以打包并压缩为一个Java文档文件（JAR）的.class文件，Java解释器负责这些文件的查找、装载和解释；
- 类库实际上是一组类文件，每个文件都有一个public类和任意数量的非public类，因此每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字package；
- **如果使用package语句，它必须是文件中除注释外的第一句程序代码；**
- **package和import关键字允许你做的，是将单一的全局名字空间分割开，使得无论多少人编写类，都不会出现名称冲突的问题；**
- 一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下；
- 如何**创建独一无二的名称**及怎样查找
  - 按照惯例，package名称的第一部分是类的创建者的反顺序的Internet域名，Internet域名应该是独一无二的；
  - 把package的名称分解为你机器上的一个目录；

- 在使用了有冲突名字的情况下，必须返回到指定全名的方式；

- 包必须位于其名称所指定的目录之中，而该目录必须是在以CLASSPAATH开始的目录中可以查询到的；

## 6.2 Java访问权限修饰词

- 包访问权限：当前包中所有其他类对那个成员都有访问权限；
- public：无论是谁，无论在哪里，都可以访问该成员；
- 继承而来的类既可以访问public成员，也可以访问protected成员；
- 对于**处于相同目录，却没有给自己设定任何包名称的类**，Java将这些文件自动看作隶属于默认包；
- private：除了**包含该成员的类**之外，其他任何类都无法访问这个成员；
- 类的客户端程序员是无法访问包访问权限的成员的；
- **protected也提供包访问权限；**

## 6.3 实现和接口

- 访问权限的控制常被称为是**具体实现的隐藏**；把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是**封装**；
- 访问权限控制：1）设定客户端程序员可以使用和不可以使用的边界；2）将接口和具体实现进行分离；

## 6.4 类的访问权限

- 如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用于整个类的定义来达到目的；
- 每个编译单元只有一个public；
- public类名称必须与编译单元名称相同；
- 编译单元内完全不带public类也是可能的，这种情况可以随意取名；
- 类的访问权限仅有两种：1）包访问权限；2）public；
- 如果不希望其他人拥有对该类的访问权限，可以把所有的构造器都指定为private；

