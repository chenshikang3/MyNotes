数据库相关概念介绍：

- 问题：
  - 数据存储：变量（基本类型，引用类型）

    - 基本类型：少量数据
    - 引用类型：保证数据完整性

  - 数据源

    - 声明直接赋值
    - IO流从硬盘读

    只干两件事声明变量存储数据，编写逻辑处理数据

    代码是先声明后执行

  - java处理数据，如果数据存储的特别凌乱，会造成，数据读取效率低，数据出现冗余
  
- 解决

  - 使用数据库，java是用硬盘里的数据，数据库是帮我们把数据存入硬盘

- 使用

  - 数据库存储数据
  - 数据库获取数据

- 概念

  - 数据：描述现实生活事物的符号

  - 数据库：用来存储数据的库（在硬盘里开辟的空间，数据库管理系统+库）

  - 数据库管理系统：用户用来操作数据库的软件

  - 数据库应用系统：在数据库管理系统之上的系统，专门给普通用户进行使用的系统

  - 数据库系统：用户+（数据库管理系统+数据库）+数据库应用系统（程序员开发的就是数据库应用系统，客户通过应用系统操作数据库管理系统）+数据库管理员

  - 常见数据库存储结构：

    - 网状数据库
    - 层次数据库
    - **关系数据库**（使用二维表，纵向：数据的描述，横向：数据的关系）
    - 对象数据库
    - NOSQL数据库

  - 常见的数据库管理系统：

    - **oracle**
    - **mysql**
    - sql server
    - DB2
    - Access

---

oracle介绍

- 介绍：大型数据库，适用于大型项目的数据存储

- 作用：管理数据的存储和读取

- 使用：

  - 软件的安装卸载

    - oracle xe版本，一路next
    - PLSql：第三方提供的客户端插件
    - 卸载：手动卸载，百度经验（要把注册表删干净）

  - 软件使用

    - 如何验证安装成功：

      菜单->oracle->运行sql命令行->conn system/密码

    - 安装内容

      - 数据库管理系统（一个）
      - 数据库（多个）
        - SID：数据库的唯一标识符
        - Oracle XE 版本默认安装数据库名为XE
      - 软件服务介绍（程序在操作系统上运行，必须要开启服务，让操作系统知道，可以调用） 
        - OracleServiceXE：相当于Oracle的开关
        - OracleXETNSListener：监听器
      - 软件目录结构介绍：
        - 安装路径：D:\oracleXE_Install\app\oracle
        - oradata：数据库空间
        - product：数据库管理系统的相关信息
          - bin目录： 数据库管理系统软件的启动目录sqlplus.exe
          - jdbc目录：数据库和java连接需要的jar包
          - network：数据库管理系统所需网络配置目录
          - log目录：oracle异常日志信息存储目录

    - 软件原理

      - 软件体系架构
        - B/S架构：Blowser/Server（浏览器服务器模式）浏览器相当于一个公共的客户端，服务器压力大
  
- C/S架构：Client/Server（客户端服务器模式）体验度好，一对一专用
  
- oracle是基于C/S架构的
  
  - 基本交互流程
  
    oralce客户端（位置地域不限）-》（ip、端口号、协议、库名）-》oracle服务器-》数据库

---

本地网络服务和监听配置

- 本地网络服务配置：D:\oracleXE_Install\app\oracle\product\11.2.0\server\network\ADMIN\tnsnames.ora
  - 作用：oracle客户端会自动加载其中的文件内容，连接配置好的数据库
  
  - 内容：存储有库的ip、端口、协议、库名
  
  - XE =
      (DESCRIPTION =
        (ADDRESS = (PROTOCOL = TCP)(HOST = Kangkang)(PORT = 1521))
        (CONNECT_DATA =
          (SERVER = DEDICATED)
      (SERVICE_NAME = XE)
    )
  )

- 不配置的话，在plsql登入的数据库界面写地址/库名

  <img src="D:\数据\学习笔记\数据库\网络服务配置.png" alt="网络服务配置" style="zoom: 50%;" />

  ==plsql登入时选SYSDBA==

  - 监听器配置
  
    客户端拿网络服务找服务器，服务器用监听器监听客户端D:\oracleXE_Install\app\oracle\product\11.2.0\server\network\ADMIN\listener.ora
  
    - 常见错误：ora-12514
    
    - 解决：
    
      修改listener.ora
    
      增加：
    
      (SID_DESC =
            (GLOBAL_NAME = XE)
            (ORACLE_HOME = D:\oracleXE_Install\app\oracle\product\11.2.0\server)
            (SID_NAME = XE）
          )
    
      重启监听服务OracleXETNSListener

  oracle的数据库管理系统就包括客户端和服务器：

  - 用户通过操作客户端操作服务器，由服务器操作数据库

  - 用户可通过安装客户端，连接别人的服务器，访问别人的库

  - 客户端和服务器分离，减轻了客户端的压力

  - 需要知道，ip，端口号，库名

- oracle自带账户：

  - 账户名：
    1. System：系统账户（管理员）
    2. Sys：超级用户（工程师）

  - Sys账户比System账户的权限要多

  - 注：oracleXE版本不自带普通用户

    11g和10g自带一个scott普通用户，默认密码为：tiger，并自带四张二维表数据

- Oracle新建用户：

  1. 必须使用System账户进行用户创建

     打开plsql，使用System账户登录，注意，登录身份选择sysdba

     ==出现system没有sysdba权限时==

     ```
     (在sql命令行窗口下)
     --使用sys账户登录
     conn sys/（密码） as sysdba
     --授予system账户sysdba权限
     grant sysdba to system
     --使用system在sysdba权限下登录
     conn system/（密码） as sysdba
     ```

     

  2. 新建sql命令窗口（执行命令）

     ==注意语法，每行都要加分号==
     
     ```
     --创建用户
     	--create user 用户名 identified by 密码
     	create user scott identified by csk123456;
     	-- 给用户赋予权限
     	-- 赋予数据库登录连接权限
     	grant connect to scott;
     	-- 赋予资源操纵权限
  	grant resource to scott;
     ```

  3. 导入表

     tools-》import tables-》SQL Inserts

     选路径，导入，注意，==上方勾选 Use Command Window==

     <img src="D:\数据\学习笔记\数据库\导入表.png" alt="导入表" style="zoom: 25%;" />

---

- sql语言的学习  ==不区分大小写==
  - 概念：结构化语句
  - 作用：
    - 用来操作数据
      - 数据的读取
        - 单表查询
        - 多表查询
        - 子查询
      - 数据的存储
        - 增加
          - 增加一条数据
          - 增加一张表
        - 删除
          - 删除数据
          - 删除表
        - 修改
          - 修改数据
          - 修改表信息
    - 用来管理用户
      - 创建用户
      - 修改用户
      - 删除用户
    - 用来管理用户
    - 用来管理事务

---

知识点学习流程

1. 完成单表的增删改查
2. 完成多表的查询
3. 完成子查询
4. 完成用户的管理
5. 完成表的管理
6. 序列、视图、索引
7. 数据库的分页查询
8. 数据库的备份
9. 事务管理

---

基本概念

- 元组：行数据（记录）
- 属性：列数据（字段）
- 属性名：列名称（字段名）
- 主键：唯一确定元组的属性组（关键字） #可自己设定，就像==学号==标识每个学生一样
- 域：属性的取值范围

---

==查询部分不会改变数据库中的内容==

- 单表的查询、别名使用

```
--单表的查询学习
  --查询表是所有数据 select * from 表名；
  select * from emp;
  --查询表中指定字段的值 select 字段名1,字段名2,字段名3... from emp
  select empno,ename from emp;
  --查询结果中使用字段别名 select 字段名 as "别名" from emp;
    --注意：as关键字可以不写，别名中没有特殊字符（空格等）双引号也可以不写。
    --作用：方便查看查询结果。
  select empno 员工号,ename"员工姓名",job as 工作,mgr as "领导编号" from emp;
```

- 连接符

```
--连接符 ||,相当于java中的'+'
  --中间的字用单引号
  --注意：一个拼接好的连接在结果中是作为一个心的字段显示，可以使用别名优化字段显示
  select empno||'的名字是'||ename from emp;
```

- 去重

```
--去除重复
    --使用distinct关键字,select distinct 字段名1,字段名2... from 表名;
    --注意：去除重复的规则是按照行进行去除的，多行数据（每个字段）完全相同取其一。
  select distinct job from emp;
```

- 排序

```
--排序
    --单字段排序
      --select * from emp order by 字段名 desc（升降序）;
      --默认升序，asc升序，desc降序
      select empno,job as "不知道",ename from emp order by ename desc;
    --多字段排序
      --第一个字段完全相同，再按第二个字段排序（注意不是第一个字段的首字母相同）
      --为每个字段升序降序要跟在字段名后，再是下一个字段 
      select * from emp order by job desc,empno asc;
```

- 逻辑运算

```
--字段的逻辑运算
    --对数字可以做四则运算"+"
    --对字符做字符连接"||"
    --字段间也可以进行运算，数字加数字，字符拼接字符
  select empno,ename,job,sal*2+1000 from emp;
  select empno+sal,ename||job from emp;
```

---

Where字句查询：==where必须紧跟在表名后面==

- 使用Where关键字进行查询结果筛选	

```
--select 字段名,字段名,... from 表名 where 筛选条件
```

- 不等于号'<>' 
  
- ‘like’ 、‘not like’
  
- ‘and’ 的级别高于 ‘or’
  
- where子句关键字：and,or,like,is null,is not null,in,between and
  
  ```
  --select * from 表名 where 字段名 is null（查询该字段值为空的信息）
    --多条件使用"and"关键字连接，筛选的是满足所有条件的数据
    select * from emp where comm is null;
    select * from emp where comm is not null and comm>1000;
    --查询姓名中包含s的，以s开头的，以s结尾的，第二个字符为A的，使用'like'关键字
    select * from emp where ename like '%S%';  --包含s，百分号表示任意多个
    select * from emp where ename like 'S%'; --s开头
    select * from emp where ename like '%S'; --s结尾
    select * from emp where ename like '_A%'; --包含s，'_'表示一个字符
    select * from emp where ename like '%/_%' escape '/'; --转译字符，escape把'/'变成转译字符
    --escape可以把普通字符变成转译字符，转译字符可以把特殊字符变成普通字符 
    
    --查询工作为SALESMAN,ANALYST,的员工信息
    --使用'or'关键字表示或者
    select * from emp where job='SALESMAN' or job='ANALYST';
    --使用'in'关键字也可以表示或查询，但'in'中的内容必须为同一个字段
    select * from emp where job in('SALESMAN','ANALYST');
    
    --查询工资在2000-3000的员工信息
    select * from emp where sal>2000 and sal<3000;
    select * from emp where sal between 2000 and 3000; -- 包含2000和3000
  ```

==报错：SQL未正确结束，原因是没有分号结尾==

---

作业

```
select * from emp; 
--选择部门30中的所有员工
  --select * from emp where deptno='30';
  
--列出所有办事员(CLERK)的姓名，编号和部门编号
  --select ename, empno, deptno from emp where job='CLERK';
  
--找出佣金高于薪金的员工
  --select * from emp where comm>sal;
  
--找出佣金高于薪金的60%的员工
  --select * from emp where comm>sal*0.6;
  
--找出部门10中所有经理(MANAGER)和部门20中所有办事员(CLERK)的详细资料
  --select * from emp where (deptno='10' and job='MANAGER') or (deptno='20' and job='CLERK');

--找出部门10中所有经理(MANAGER),部门20中所有办事员(CLERK),既不是经理又不是办事员但其薪金大于或等于2000的所有员工的详细资料.
  --select * from emp where (deptno='10' and job='MANAGER') 
  --or (deptno='20' and job='CLERK') or (job not in('CLERK','MANAGER') and sal>=2000);

--找出收取佣金的员工的不同工作. 
  --select distinct job from emp where comm is not null; 
  
--找出不收取佣金或收取的佣金低于100的员工.
  --select * from emp where comm is null or comm<100;
  
--找出早于82年前受雇的员工.
  --select * from emp where hiredate < '01-1月-1982' order by hiredate;
  
--显示不带有"R"的员工的姓名
  --select * from emp where ename not like '%R%' escape '/';
  
--显示员工的详细资料,按姓名排序.
  --select * from emp order by ename;
  
--显示员工的姓名和受雇日期,根据其服务年限,将最老的员工排在最前面.
  --select ename,hiredate from emp order by hiredate;

--显示所有员工的姓名、工作和薪金,按工作的降序排序,若工作相同则按薪金排序
  --select ename,job,sal from emp order by job desc, sal desc;

--显示姓名字段的任何位置包含"A"的所有员工的姓名.
  select ename from emp where ename like '%A%';
```

---

oracle函数学习（单行函数、多行函数、转换函数、其他函数）

- 单行函数学习（1、不改变真实数据，只是对数据做修饰显示；2、可以和字段混合使用）

  ==混用：函数名（字段名），字段名==

  - 字符函数：select 字段名，函数名（字段名），字段名...  from 表名

    ```
    --查询所有员工信息，员工姓名小写显示
    select empno,lower(ename),job,mgr from emp;
    --查询所有员工的信息，姓名首字母大写；
    select initcap(ename) from emp;
    ```

    | **函 数**                                            | **功 能**        | **示 例**                               | **结 果**          |
    | ---------------------------------------------------- | ---------------- | --------------------------------------- | ------------------ |
    | **INITCAP  (char)**                                  | **首字母大写**   | **initcap**  **('hello')**              | **Hello**          |
    | **LOWER  (char)**                                    | **转换为小写**   | **lower ('FUN')**                       | **fun**            |
    | **UPPER  (char)**                                    | **转换为大写**   | **upper ('sun')**                       | **SUN**            |
    | **LTRIM  (char, set)**                               | **左剪裁**       | **ltrim ('xyzadams',  'xyz')**          | **adams**          |
    | **RTRIM  (char, set)**                               | **右剪裁**       | **rtrim ('xyzadams',  'ams')**          | **xyzad**          |
    | **TRANSLATE  (char, from, to)**                      | **按字符翻译**   | **translate ('jack', 'abcd',  '1234')** | **j13k**           |
    | **REPLACE  (char,** **search_str,** **replace_str)** | **字符串替换**   | **replace ('jack and jue',  'j', 'b')** | **black and blue** |
    | **INSTR  (char,** **substr[, pos])**                 | **查找子串位置** | **instr**  **('worldwide', 'd')**       | **5**              |
    | **SUBSTR  (char, pos,** **len)**                     | **取子字符串**   | **substr**  **('abcdefg',3,2)**         | **cd**             |
    | **CONCAT  (char1, char2)**                           | **连接字符串**   | **concat**  **('Hello', 'world')**      | **Helloworld**     |

  - 数值函数：

    ```
    --伪表：不是真实存在的表，是为了方便进行数据的验证而临时存在的表,表名为dual
    select * from dual;
    
    select abs(-1),ceil(2.2) from dual;
    ```

    | **函 数**            | **功 能**    | **示 例**            | **结 果**      |
    | -------------------- | ------------ | -------------------- | -------------- |
    | **ABS(n)**           | **取绝对值** | **abs(-15)**         | **15**         |
    | **CEIL(n  )**        | **向上取整** | **ceil(44.778)**     | **45**         |
    | **SIN(n)**           | **正弦**     | **sin(1.571)**       | **.999999979** |
    | **COS(n)**           | **余弦**     | **cos**(0)           | **1**          |
    | **SIGN(n)**          | **取符号**   | **sign(-32)**        | **-1**         |
    | **FLOOR(n)**         | **向下取整** | **floor(100.2)**     | **100**        |
    | **POWER(**m,n  **)** | **m**的n次幂 | **power(4,2)**       | **16**         |
    | **MOD(**m,n)         | **取余数**   | **mod(10,3)**        | **1**          |
    | **ROUND(**m,n**)**   | **四舍五入** | **round(100.256,2)** | **100.26**     |
    | **TRUNC(m,n)**       | **截断**     | **trunk(100.256,2)** | **100.25**     |
    | **SQRT(n)**          | **平方根**   | **sqrt(4)**          | **2**          |

  - 日期函数

    ```
    select months_between('01-1月-2018','12-6月-2017') from dual;
    --注意两点：1、选择的指定日期是离你最近的那个;2、'星期日'不是'星期天';
    select next_day('17-11月-2019','星期日') from dual;
    
    --round函数,'year'按月四舍五入,上半年下半年;'month'按日四舍五入，上半月下半月;'day'按日四舍五入,上半周下半周,从周日开始算;
    ```

    | 函 数          | 功 能                            | 示 例                                                        | 结 果                           |
    | -------------- | -------------------------------- | ------------------------------------------------------------ | ------------------------------- |
    | MONTHS_BETWEEN | 返回两个日期间的月份             | months_between  ('04-11月-05','11-1月-01')                   | 57.7741935                      |
    | ADD_MONTHS     | 返回把月份数加到日期上的新日期   | add_months('06-2月-03',1)  add_months('06-2月-03',-1)        | 06-3月-03  06-1月-03            |
    | NEXT_DAY       | 返回指定日期后的星期对应的新日期 | next_day('06-2月-03','星期一')                               | 10-2月-03                       |
    | LAST_DAY       | 返回指定日期所在的月的最后一天   | last_day('06-2月-03')                                        | 28-2月-03                       |
    | ROUND          | 按指定格式对日期进行四舍五入     | round(to_date('13-2月-03'),'YEAR')    round(to_date('13-2月-03'),'MONTH')  round(to_date('13-2月-03'),'DAY') | 01-1月-03  01-2月-03  16-2月-03 |
    | TRUNC          | 对日期按指定方式进行截断         | trunc(to_date('06-2月-03'),'YEAR')  trunc(to_date('06-2月-03'),'MONTH')  trunc(to_date('06-2月-03'),'DAY') | 01-1月-03  01-2月-03  02-2月-03 |

- 多行函数（max,min,avg,sum,count）

  - 对多行数据比较，显示一条，单行函数显示多条；
  - **多行函数不能和字段直接混用，除非分组；**
  - **多行函数不能和单行函数混用，除非分组；**
  - 多行函数之间可以混用；
  - 作用：用于对查询数据的统计；

  ```
  --子查询
  select ename from emp where sal=(select max(sal) from emp);
  
  --查询一整个表有多少数据，用'*'
  select count(*) from emp;
  --值为null，count不计数
  
  --查询公司有多少工作种类
  select count(distinct job) from emp;
  ```

- 转换函数

  to_number()：将字符转换为数值

  to_char()：将数值或日期转换为字符

  to_date()：将字符转换为日期

  ==以字符为基础互转==

  - 字符和数值的互转
    - 字符转数字：char→number

    ```
    select to_number('123') from dual;
    --只有数值才能进行运算
    select to_number('123')+2 from dual;
    ```
    - 数字转字符：number→char

    ```
    --可以指定显示格式（'9'表示占位,'L'表示人民币符号,'$'表示美元符号，'0'作为占位和补位）
    select to_char(123456789,'L999,999,999') from dual;
    ```

    ==to_number()和to_char()之间的转换是隐式自动的，可以不写==

  - 日期和字符的互转

    ==一般新增数据使用to_date();查询数据使用to_char()==

    - 字符转日期：char→date
    
    ```
    --to_date('要转换的字符','指定格式') 1、字符要符合格式;2、默认的格式为:'1-1月-2018';3、常用的格式:yyyy-mm-dd yyyy/mm/dd;
select * from emp where hiredate > to_date('1982-01-01','yyyy-mm-dd');
    ```

    - 日期转字符：date→char
    
    ```
    --使用默认格式转换
    select to_char(hiredate) from emp;
    --指定格式
select to_char(hiredate,'yyyy-mm-dd') from emp;
    --中间加入特定字符加双引号
    select to_char(hiredate, 'yyyy"a"mm"a"dd') from emp;
    ```
    
  
- 其他函数（nvl(), nvl2(), decode()）

  ```
  --nvl(字段名,新的值):如果字段值不为null，返回该字段值，否则返回新的值;
  select ename,sal,comm,sal+nvl(comm,0) from emp;
  --nvl2(字段名,处理1,处理2):如果字段值为null，执行处理1，否则执行处理2;
  select ename,nvl2(comm,sal+comm,sal) from emp;
  --decode(字段名,'值1','处理1','值2','处理2'...'公共处理'):如果字段的值与decode中的条件值相同则执行相应处理，否则执行公共处理，公共处理可以没有;
  select ename,job,decode(job,'MANAGER','经理','PRESDENT','董事长','其他员工') from emp;
  ```

---

oracle分组（关键字：group by 分组字段名,分组字段名...）

==分组之后，select后面只能加**分组字段**和**多行函数**==

如果按多字段分组，则先按第一个字段分组，每个小组再按第二个字段分小组，以此类推

```
--查询不同部门的最高工资
select deptno,max(sal) from emp group by deptno;
--查询不同工作岗位的员工数
select job,count(*) from emp group by job;
--查询不同部门的不同工作岗位的人数
select deptno,job,count(*) from emp group by deptno,job order by deptno; 
```

分组筛选（关键字：having）

==where语句中不允许出现多行函数==

==where必须紧跟在表名后面==

having作用：针对分组进行分组之后的数据筛选，允许使用多行函数；

having必须和分组结合，**不允许单独使用**；

- where执行顺序：from→where→group by→select→order by

- having执行顺序：from→group by→select→having→order by

where效率高，执行顺序where > 多行函数 > having

```
--查询不同部门的不同工作岗位的并且人数大于1的信息
（错误示范）select deptno,job,count(*) from emp where count(*)>1 group by deptno,job order by deptno; --where语句中不允许出现多行函数
因为where是先筛选，count是计筛选以后的数，把count作为筛选的条件，则说明还没有开始筛选就已经有筛选后的计数结果了，在逻辑上是矛盾的;
--使用having关键字进行分组筛选
--having是在count之后再筛
select deptno,job,count(*) from emp having count(*)>1 group by deptno,job order by deptno;
--查询部门号大于10的不同部门的不同工作岗位的人数；
select deptno,job,count(*) from emp group by deptno,job having deptno>10;
```

---

**增删改&数据备份**

==增删改的数据SQL语句执行完毕后，不会立马进入数据写入==

==还需要手动对数据进行提交，如果数据有问题还可以回滚，点击“回滚”即撤销==

- 增加数据

  使用insert into字段：insert into 表名（字段1,字段2,字段3...）values（值1,值2,值3...）

  注意1：在没有非空设置的情况下，非主键的字段可以为空

  ==在plsql中ctrl+点击表名，可以进入表的信息设置==

  注意2：值和字段必须一一对应，前面有几个字段，后面就得有几个值，数量顺序都得对应

  注意3：如果是全字段插入，可以省略字段名，insert into 表名  values（值1,值2,值3...）

```
--在部门中增加一个新的部门信息，信息内容为 编号：50，名称：LOL学院，地址：北京;
insert into dept(deptno,dname,loc)values(50,'LOL学院','北京');
--在部门新增一条数据，只有部门编号和名称，没有地址
insert into dept (deptno, dname)values(60,'吃鸡学院')

--将dept表中的数据全部写入deptBak中，前提是两个的字段一样，顺序一样
insert into deptBak select * from dept
```

- 删除数据

  - delete from 表名 --删除表中的所有记录，不是删表，是删数据

    truncate table 表名  --删除表中的所有记录，但是效率高于delete

    drop table dept --删表

  - delete from 表名 where 条件

- 更新数据

  - update 表名 set 字段名=新的值,字段名=新的值,字段名=新的值... --将字段全部的值修改
  - update 表名 set 字段名=新的值,字段名=新的值,字段名=新的值... where 条件 --将符合条件的修改

- 数据备份

  - 表级别备份：

    1. 全部备份：create table 新的表名 as select * from 需要备份的表名；

       ==只会备份数据和结构，不会备份约束（比如主键）==

       ```
       --备份后的表名为deptBak
       create table deptBak as select * from dept;
       ```

    2. 部分备份：create table 新的表名 as select 字段名1,字段名2... from 需要备份的表名；

       备份的是select的结果集

       ```
       create table deptBak2 as select deptno, dname from dept;
       ```

  - 数据整体插入

    insert into 插入表名 select * from 需要备份表名，注：两个表的字段数量要一致，顺序要一致，类型要一致；

  

  

**概念：**

- 主键：非空、唯一，设为主键，作用是唯一标识一条数据；