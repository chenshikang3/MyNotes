

# 数据库相关概念介绍：

- 问题：
  - 数据存储：变量（基本类型，引用类型）

    - 基本类型：少量数据
    - 引用类型：保证数据完整性

  - 数据源

    - 声明直接赋值
    - IO流从硬盘读

    只干两件事声明变量存储数据，编写逻辑处理数据

    代码是先声明后执行

  - java处理数据，如果数据存储的特别凌乱，会造成，数据读取效率低，数据出现冗余
  
- 解决

  - 使用数据库，java是用硬盘里的数据，数据库是帮我们把数据存入硬盘

- 使用

  - 数据库存储数据
  - 数据库获取数据

- 概念

  - 数据：描述现实生活事物的符号

  - 数据库：用来存储数据的库（在硬盘里开辟的空间，数据库管理系统+库）

  - 数据库管理系统：用户用来操作数据库的软件

  - 数据库应用系统：在数据库管理系统之上的系统，专门给普通用户进行使用的系统

  - 数据库系统：用户+（数据库管理系统+数据库）+数据库应用系统（程序员开发的就是数据库应用系统，客户通过应用系统操作数据库管理系统）+数据库管理员

  - 常见数据库存储结构：

    - 网状数据库
    - 层次数据库
    - **关系数据库**（使用二维表，纵向：数据的描述，横向：数据的关系）
    - 对象数据库
    - NOSQL数据库

  - 常见的数据库管理系统：

    - **oracle**
    - **mysql**
    - sql server
    - DB2
    - Access

---

# oracle介绍

- 介绍：大型数据库，适用于大型项目的数据存储

- 作用：管理数据的存储和读取

- 使用：

  - 软件的安装卸载

    - oracle xe版本，一路next
    - PLSql：第三方提供的客户端插件
    - 卸载：手动卸载，百度经验（要把注册表删干净）

  - 软件使用

    - 如何验证安装成功：

      菜单->oracle->运行sql命令行->conn system/密码

    - 安装内容

      - 数据库管理系统（一个）
      - 数据库（多个）
        - SID：数据库的唯一标识符
        - Oracle XE 版本默认安装数据库名为XE
      - 软件服务介绍（程序在操作系统上运行，必须要开启服务，让操作系统知道，可以调用） 
        - OracleServiceXE：相当于Oracle的开关
        - OracleXETNSListener：监听器
      - 软件目录结构介绍：
        - 安装路径：D:\oracleXE_Install\app\oracle
        - oradata：数据库空间
        - product：数据库管理系统的相关信息
          - bin目录： 数据库管理系统软件的启动目录sqlplus.exe
          - jdbc目录：数据库和java连接需要的jar包
          - network：数据库管理系统所需网络配置目录
          - log目录：oracle异常日志信息存储目录

    - 软件原理

      - 软件体系架构
        - B/S架构：Blowser/Server（浏览器服务器模式）浏览器相当于一个公共的客户端，服务器压力大
  
- C/S架构：Client/Server（客户端服务器模式）体验度好，一对一专用
  
- oracle是基于C/S架构的
  
  - 基本交互流程
  
    oralce客户端（位置地域不限）-》（ip、端口号、协议、库名）-》oracle服务器-》数据库

---

# 本地网络服务和监听配置

- 本地网络服务配置：D:\oracleXE_Install\app\oracle\product\11.2.0\server\network\ADMIN\tnsnames.ora
  - 作用：oracle客户端会自动加载其中的文件内容，连接配置好的数据库
  
  - 内容：存储有库的ip、端口、协议、库名
  
  - XE =
      (DESCRIPTION =
        (ADDRESS = (PROTOCOL = TCP)(HOST = Kangkang)(PORT = 1521))
        (CONNECT_DATA =
          (SERVER = DEDICATED)
      (SERVICE_NAME = XE)
    )
  )

- 不配置的话，在plsql登入的数据库界面写地址/库名

  <img src="D:\数据\学习笔记\数据库\网络服务配置.png" alt="网络服务配置" style="zoom: 50%;" />

  ==plsql登入时选SYSDBA==

  - 监听器配置
  
    客户端拿网络服务找服务器，服务器用监听器监听客户端D:\oracleXE_Install\app\oracle\product\11.2.0\server\network\ADMIN\listener.ora
  
    - 常见错误：ora-12514
    
    - 解决：
    
      修改listener.ora
    
      增加：
    
      (SID_DESC =
            (GLOBAL_NAME = XE)
            (ORACLE_HOME = D:\oracleXE_Install\app\oracle\product\11.2.0\server)
            (SID_NAME = XE）
          )
    
      重启监听服务OracleXETNSListener

  oracle的数据库管理系统就包括客户端和服务器：

  - 用户通过操作客户端操作服务器，由服务器操作数据库

  - 用户可通过安装客户端，连接别人的服务器，访问别人的库

  - 客户端和服务器分离，减轻了客户端的压力

  - 需要知道，ip，端口号，库名

- oracle自带账户：

  - 账户名：
    1. System：系统账户（管理员）
    2. Sys：超级用户（工程师）

  - Sys账户比System账户的权限要多

  - 注：oracleXE版本不自带普通用户

    11g和10g自带一个scott普通用户，默认密码为：tiger，并自带四张二维表数据

- Oracle新建用户：

  1. 必须使用System账户进行用户创建

     打开plsql，使用System账户登录，注意，登录身份选择sysdba

     ==出现system没有sysdba权限时==

     ```
     (在sql命令行窗口下)
     --使用sys账户登录
     conn sys/（密码） as sysdba
     --授予system账户sysdba权限
     grant sysdba to system
     --使用system在sysdba权限下登录
     conn system/（密码） as sysdba
     ```

     

  2. 新建sql命令窗口（执行命令）

     ==注意语法，每行都要加分号==
     
     ```
     --创建用户
     	--create user 用户名 identified by 密码
     	create user scott identified by csk123456;
     	-- 给用户赋予权限
     	-- 赋予数据库登录连接权限
     	grant connect to scott;
     	-- 赋予资源操纵权限
  		grant resource to scott;
     ```

  3. 导入表

     tools-》import tables-》SQL Inserts

     选路径，导入，注意，==上方勾选 Use Command Window==

     <img src="D:\数据\学习笔记\数据库\导入表.png" alt="导入表" style="zoom: 25%;" />

---

# sql语言的学习  ==不区分大小写==

- 概念：结构化语句
- 作用：
  - 用来操作数据
    - 数据的读取
      - 单表查询
      - 多表查询
      - 子查询
    - 数据的存储
      - 增加
        - 增加一条数据
        - 增加一张表
      - 删除
        - 删除数据
        - 删除表
      - 修改
        - 修改数据
        - 修改表信息
  - 用来管理用户
    - 创建用户
    - 修改用户
    - 删除用户
  - 用来管理用户
  - 用来管理事务

---

# 知识点学习流程

1. 完成单表的增删改查
2. 完成多表的查询
3. 完成子查询
4. 完成用户的管理
5. 完成表的管理
6. 序列、视图、索引
7. 数据库的分页查询
8. 数据库的备份
9. 事务管理

---

# 基本概念

- 元组：行数据（记录）
- 属性：列数据（字段）
- 属性名：列名称（字段名）
- 主键：唯一确定元组的属性组（关键字） #可自己设定，就像==学号==标识每个学生一样
- 域：属性的取值范围

---

==查询部分不会改变数据库中的内容==

# 基本查询、连接、去重、排序、运算

- 单表的查询、别名使用

```
--单表的查询学习
  --查询表是所有数据 select * from 表名；
  select * from emp;
  --查询表中指定字段的值 select 字段名1,字段名2,字段名3... from emp
  select empno,ename from emp;
  --查询结果中使用字段别名 select 字段名 as "别名" from emp;
    --注意：as关键字可以不写，别名中没有特殊字符（空格等）双引号也可以不写。
    --作用：方便查看查询结果。
  select empno 员工号,ename"员工姓名",job as 工作,mgr as "领导编号" from emp;
```

- 连接符

```
--连接符 ||,相当于java中的'+'
  --中间的字用单引号
  --注意：一个拼接好的连接在结果中是作为一个心的字段显示，可以使用别名优化字段显示
  select empno||'的名字是'||ename from emp;
```

- 去重

```
--去除重复
    --使用distinct关键字,select distinct 字段名1,字段名2... from 表名;
    --注意：去除重复的规则是按照行进行去除的，多行数据（每个字段）完全相同取其一。
  select distinct job from emp;
```

- 排序

```
--排序
    --单字段排序
      --select * from emp order by 字段名 desc（升降序）;
      --默认升序，asc升序，desc降序
      select empno,job as "不知道",ename from emp order by ename desc;
    --多字段排序
      --第一个字段完全相同，再按第二个字段排序（注意不是第一个字段的首字母相同）
      --为每个字段升序降序要跟在字段名后，再是下一个字段 
      select * from emp order by job desc,empno asc;
```

- 逻辑运算

```
--字段的逻辑运算
    --对数字可以做四则运算"+"
    --对字符做字符连接"||"
    --字段间也可以进行运算，数字加数字，字符拼接字符
  select empno,ename,job,sal*2+1000 from emp;
  select empno+sal,ename||job from emp;
```

---

# Where字句查询：==where必须紧跟在表名后面==

- 使用Where关键字进行查询结果筛选	

```
--select 字段名,字段名,... from 表名 where 筛选条件
```

- 不等于号'<>' 
  
- ‘like’ 、‘not like’
  
- ‘and’ 的级别高于 ‘or’
  
- where子句关键字：and,or,like,is null,is not null,in,between and
  
  ```
  --select * from 表名 where 字段名 is null（查询该字段值为空的信息）
    --多条件使用"and"关键字连接，筛选的是满足所有条件的数据
    select * from emp where comm is null;
    select * from emp where comm is not null and comm>1000;
    --查询姓名中包含s的，以s开头的，以s结尾的，第二个字符为A的，使用'like'关键字
    select * from emp where ename like '%S%';  --包含s，百分号表示任意多个
    select * from emp where ename like 'S%'; --s开头
    select * from emp where ename like '%S'; --s结尾
    select * from emp where ename like '_A%'; --包含s，'_'表示一个字符
    select * from emp where ename like '%/_%' escape '/'; --转译字符，escape把'/'变成转译字符
    --escape可以把普通字符变成转译字符，转译字符可以把特殊字符变成普通字符 
    
    --查询工作为SALESMAN,ANALYST,的员工信息
    --使用'or'关键字表示或者
    select * from emp where job='SALESMAN' or job='ANALYST';
    --使用'in'关键字也可以表示或查询，但'in'中的内容必须为同一个字段
    select * from emp where job in('SALESMAN','ANALYST');
    
    --查询工资在2000-3000的员工信息
    select * from emp where sal>2000 and sal<3000;
    select * from emp where sal between 2000 and 3000; -- 包含2000和3000
  ```

==报错：SQL未正确结束，原因是没有分号结尾==

---

# 作业

- 查看字符长度函数length（字段名）
- 获取系统当前时间，sysdate
- 排序中可以使用别名

```
select * from emp; 
--选择部门30中的所有员工
  --select * from emp where deptno='30';
  
--列出所有办事员(CLERK)的姓名，编号和部门编号
  --select ename, empno, deptno from emp where job='CLERK';
  
--找出佣金高于薪金的员工
  --select * from emp where comm>sal;
  
--找出佣金高于薪金的60%的员工
  --select * from emp where comm>sal*0.6;
  
--找出部门10中所有经理(MANAGER)和部门20中所有办事员(CLERK)的详细资料
  --select * from emp where (deptno='10' and job='MANAGER') or (deptno='20' and job='CLERK');

--找出部门10中所有经理(MANAGER),部门20中所有办事员(CLERK),既不是经理又不是办事员但其薪金大于或等于2000的所有员工的详细资料.
  --select * from emp where (deptno='10' and job='MANAGER') 
  --or (deptno='20' and job='CLERK') or (job not in('CLERK','MANAGER') and sal>=2000);

--找出收取佣金的员工的不同工作. 
  --select distinct job from emp where comm is not null; 
  
--找出不收取佣金或收取的佣金低于100的员工.
  --select * from emp where comm is null or comm<100;

--找出各月倒数第3天受雇的所有员工
  select * from emp where hiredate = last_day(hiredate);

--显示满35年服务年限的员工的姓名和受雇日期
  select ename, hiredate from emp where (sysdate-hiredate)/365>35

--找出早于82年前受雇的员工.
  --select * from emp where hiredate < '01-1月-1982' order by hiredate;

--以首字母大写的方式显示所有员工的姓名
  select initcap(name) from emp;
  
--显示正好为5个字符的员工的姓名；
  select ename from emp where length(ename)=5;

--显示不带有"R"的员工的姓名
  --select * from emp where ename not like '%R%' escape '/';

--显示所有员工姓名的前三个字符
  select substr(ename, 1, 3) from emp; 

--显示员工的详细资料,按姓名排序.
  --select * from emp order by ename;
  
--显示员工的姓名和受雇日期,根据其服务年限,将最老的员工排在最前面.
  --select ename,hiredate from emp order by hiredate;

--显示所有员工的姓名、工作和薪金,按工作的降序排序,若工作相同则按薪金排序
  --select ename,job,sal from emp order by job desc, sal desc;

--显示姓名字段的任何位置包含"A"的所有员工的姓名.
  select ename from emp where ename like '%A%';

--取出日期中的年份、月份，to_char(hiredate,'yyyy')
  select ename, to_char(hiredate,'yyyy') year,to_char(hiredate,'mm') month from emp order by month, year;
```

---

# 10 oracle函数学习（单行函数、多行函数、转换函数、其他函数）

## 10.1 单行函数学习

（1、不改变真实数据，只是对数据做修饰显示；2、可以和字段混合使用）

==混用：函数名（字段名），字段名==

### 10.1.1 字符函数

select 字段名，函数名（字段名），字段名...  from 表名

```
--查询所有员工信息，员工姓名小写显示
select empno,lower(ename),job,mgr from emp;
--查询所有员工的信息，姓名首字母大写；
select initcap(ename) from emp;
```

| **函 数**                                            | **功 能**        | **示 例**                               | **结 果**          |
| ---------------------------------------------------- | ---------------- | --------------------------------------- | ------------------ |
| **INITCAP  (char)**                                  | **首字母大写**   | **initcap**  **('hello')**              | **Hello**          |
| **LOWER  (char)**                                    | **转换为小写**   | **lower ('FUN')**                       | **fun**            |
| **UPPER  (char)**                                    | **转换为大写**   | **upper ('sun')**                       | **SUN**            |
| **LTRIM  (char, set)**                               | **左剪裁**       | **ltrim ('xyzadams',  'xyz')**          | **adams**          |
| **RTRIM  (char, set)**                               | **右剪裁**       | **rtrim ('xyzadams',  'ams')**          | **xyzad**          |
| **TRANSLATE  (char, from, to)**                      | **按字符翻译**   | **translate ('jack', 'abcd',  '1234')** | **j13k**           |
| **REPLACE  (char,** **search_str,** **replace_str)** | **字符串替换**   | **replace ('jack and jue',  'j', 'b')** | **black and blue** |
| **INSTR  (char,** **substr[, pos])**                 | **查找子串位置** | **instr**  **('worldwide', 'd')**       | **5**              |
| **SUBSTR  (char, pos,** **len)**                     | **取子字符串**   | **substr**  **('abcdefg',3,2)**         | **cd**             |
| **CONCAT  (char1, char2)**                           | **连接字符串**   | **concat**  **('Hello', 'world')**      | **Helloworld**     |

### 10.1.2 数值函数

```
--伪表：不是真实存在的表，是为了方便进行数据的验证而临时存在的表,表名为dual
select * from dual;

select abs(-1),ceil(2.2) from dual;
```

| **函 数**            | **功 能**    | **示 例**            | **结 果**      |
| -------------------- | ------------ | -------------------- | -------------- |
| **ABS(n)**           | **取绝对值** | **abs(-15)**         | **15**         |
| **CEIL(n  )**        | **向上取整** | **ceil(44.778)**     | **45**         |
| **SIN(n)**           | **正弦**     | **sin(1.571)**       | **.999999979** |
| **COS(n)**           | **余弦**     | **cos**(0)           | **1**          |
| **SIGN(n)**          | **取符号**   | **sign(-32)**        | **-1**         |
| **FLOOR(n)**         | **向下取整** | **floor(100.2)**     | **100**        |
| **POWER(**m,n  **)** | **m**的n次幂 | **power(4,2)**       | **16**         |
| **MOD(**m,n)         | **取余数**   | **mod(10,3)**        | **1**          |
| **ROUND(**m,n**)**   | **四舍五入** | **round(100.256,2)** | **100.26**     |
| **TRUNC(m,n)**       | **截断**     | **trunk(100.256,2)** | **100.25**     |
| **SQRT(n)**          | **平方根**   | **sqrt(4)**          | **2**          |

### 10.1.3 日期函数

```
select months_between('01-1月-2018','12-6月-2017') from dual;
--注意两点：1、选择的指定日期是离你最近的那个;2、'星期日'不是'星期天';
select next_day('17-11月-2019','星期日') from dual;

--round函数,'year'按月四舍五入,上半年下半年;'month'按日四舍五入，上半月下半月;'day'按日四舍五入,上半周下半周,从周日开始算;
```

| 函 数          | 功 能                            | 示 例                                                        | 结 果                           |
| -------------- | -------------------------------- | ------------------------------------------------------------ | ------------------------------- |
| MONTHS_BETWEEN | 返回两个日期间的月份             | months_between  ('04-11月-05','11-1月-01')                   | 57.7741935                      |
| ADD_MONTHS     | 返回把月份数加到日期上的新日期   | add_months('06-2月-03',1)  add_months('06-2月-03',-1)        | 06-3月-03  06-1月-03            |
| NEXT_DAY       | 返回指定日期后的星期对应的新日期 | next_day('06-2月-03','星期一')                               | 10-2月-03                       |
| LAST_DAY       | 返回指定日期所在的月的最后一天   | last_day('06-2月-03')                                        | 28-2月-03                       |
| ROUND          | 按指定格式对日期进行四舍五入     | round(to_date('13-2月-03'),'YEAR')    round(to_date('13-2月-03'),'MONTH')  round(to_date('13-2月-03'),'DAY') | 01-1月-03  01-2月-03  16-2月-03 |
| TRUNC          | 对日期按指定方式进行截断         | trunc(to_date('06-2月-03'),'YEAR')  trunc(to_date('06-2月-03'),'MONTH')  trunc(to_date('06-2月-03'),'DAY') | 01-1月-03  01-2月-03  02-2月-03 |

## 10.2 多行函数（max,min,avg,sum,count）

- ==**对多行数据比较，显示一条**==，单行函数显示多条；
- **多行函数不能和字段直接混用，除非分组；**
- **多行函数不能和单行函数混用，除非分组；**
- 多行函数之间可以混用；
- 作用：用于对查询数据的统计；

```
--子查询
select ename from emp where sal=(select max(sal) from emp);

--查询一整个表有多少数据，用'*'
select count(*) from emp;
--值为null，count不计数

--查询公司有多少工作种类
select count(distinct job) from emp;
```

## 10.3 转换函数

to_number()：将字符转换为数值

to_char()：将数值或日期转换为字符

to_date()：将字符转换为日期

==以字符为基础互转==

### 10.3.1字符和数值的互转

- 字符转数字：char→number

```
select to_number('123') from dual;
--只有数值才能进行运算
select to_number('123')+2 from dual;
```
- 数字转字符：number→char

```
--可以指定显示格式（'9'表示占位,'L'表示人民币符号,'$'表示美元符号，'0'作为占位和补位）
select to_char(123456789,'L999,999,999') from dual;
```

==to_number()和to_char()之间的转换是隐式自动的，可以不写==

### 10.3.2 日期和字符的互转

==一般新增数据使用to_date();查询数据使用to_char()==

- 字符转日期：char→date

```
--to_date('要转换的字符','指定格式') 1、字符要符合格式;2、默认的格式为:'1-1月-2018';3、常用的格式:yyyy-mm-dd yyyy/mm/dd;
select * from emp where hiredate > to_date('1982-01-01','yyyy-mm-dd');
```

- 日期转字符：date→char

```
--使用默认格式转换
select to_char(hiredate) from emp;
--指定格式
select to_char(hiredate,'yyyy-mm-dd') from emp;
--中间加入特定字符加双引号
select to_char(hiredate, 'yyyy"a"mm"a"dd') from emp;
```

### 10.3.3 其他函数（nvl(), nvl2(), decode()）

```
--nvl(字段名,新的值):如果字段值不为null，返回该字段值，否则返回新的值;
select ename,sal,comm,sal+nvl(comm,0) from emp;
--nvl2(字段名,处理1,处理2):如果字段值为null，执行处理1，否则执行处理2;
select ename,nvl2(comm,sal+comm,sal) from emp;
--decode(字段名,'值1','处理1','值2','处理2'...'公共处理'):如果字段的值与decode中的条件值相同则执行相应处理，否则执行公共处理，公共处理可以没有;
select ename,job,decode(job,'MANAGER','经理','PRESDENT','董事长','其他员工') from emp;
```

---

## 10.4 oracle分组

（关键字：group by 分组字段名,分组字段名...）

==分组之后，select后面只能加**分组字段**和**多行函数**==

如果按多字段分组，则先按第一个字段分组，每个小组再按第二个字段分小组，以此类推

```
--查询不同部门的最高工资
select deptno,max(sal) from emp group by deptno;
--查询不同工作岗位的员工数
select job,count(*) from emp group by job;
--查询不同部门的不同工作岗位的人数
select deptno,job,count(*) from emp group by deptno,job order by deptno; 
```

分组筛选（关键字：having）

==where语句中不允许出现多行函数==

==where必须紧跟在表名后面==

having作用：针对分组进行分组之后的数据筛选，允许使用多行函数；

having必须和分组结合，**不允许单独使用**；

- where执行顺序：from→where→group by→select→order by

- having执行顺序：from→group by→select→having→order by

where效率高，执行顺序where > 多行函数 > having

```
--查询不同部门的不同工作岗位的并且人数大于1的信息
（错误示范）select deptno,job,count(*) from emp where count(*)>1 group by deptno,job order by deptno; --where语句中不允许出现多行函数
因为where是先筛选，count是计筛选以后的数，把count作为筛选的条件，则说明还没有开始筛选就已经有筛选后的计数结果了，在逻辑上是矛盾的;
--使用having关键字进行分组筛选
--having是在count之后再筛
select deptno,job,count(*) from emp having count(*)>1 group by deptno,job order by deptno;
--查询部门号大于10的不同部门的不同工作岗位的人数；
select deptno,job,count(*) from emp group by deptno,job having deptno>10;
```

---

# **11 增删改&数据备份**

==增删改的数据SQL语句执行完毕后，不会立马进入数据写入==

==还需要手动对数据进行提交，如果数据有问题还可以回滚，点击“回滚”即撤销==

## 11.1 增加数据

使用insert into字段：insert into 表名（字段1,字段2,字段3...）values（值1,值2,值3...）

注意1：在没有非空设置的情况下，非主键的字段可以为空

==在plsql中ctrl+点击表名，可以进入表的信息设置==

注意2：值和字段必须一一对应，前面有几个字段，后面就得有几个值，数量顺序都得对应

注意3：如果是全字段插入，可以省略字段名，insert into 表名  values（值1,值2,值3...）

```
--在部门中增加一个新的部门信息，信息内容为 编号：50，名称：LOL学院，地址：北京;
insert into dept(deptno,dname,loc)values(50,'LOL学院','北京');
--在部门新增一条数据，只有部门编号和名称，没有地址
insert into dept (deptno, dname)values(60,'吃鸡学院')

--将dept表中的数据全部写入deptBak中，前提是两个的字段一样，顺序一样
insert into deptBak select * from dept
```

## 11.2 删除数据

- delete from 表名 --删除表中的所有记录，不是删表，是删数据

  truncate table 表名  --删除表中的所有记录，但是效率高于delete

  drop table dept --删表

- delete from 表名 where 条件

## 11.3 更新数据

- update 表名 set 字段名=新的值,字段名=新的值,字段名=新的值... --将字段全部的值修改
- update 表名 set 字段名=新的值,字段名=新的值,字段名=新的值... where 条件 --将符合条件的修改

## 11.4 数据备份

- 表级别备份：

  1. 全部备份：create table 新的表名 as select * from 需要备份的表名；

     ==只会备份数据和结构，不会备份约束（比如主键）==

     ```
     --备份后的表名为deptBak
     create table deptBak as select * from dept;
     ```

  2. 部分备份：create table 新的表名 as select 字段名1,字段名2... from 需要备份的表名；

     备份的是select的结果集

     ```
     create table deptBak2 as select deptno, dname from dept;
     ```

- 数据整体插入

  insert into 插入表名 select * from 需要备份表名，注：两个表的字段数量要一致，顺序要一致，类型要一致；

---

# **12 多表联合查询**

（当需要获取的数据分布在多个表）

## 12.1 SQL92方式

- 笛卡尔积：多个表的数据一 一对应，结果为所有表数量的乘积

  ```
  --两个表里的数据做全排列
  select * from emp,dept;
  ```

- 筛选

  - 等值连接：先做笛卡尔积，然后等值筛选，==可以直接在select子句中使用字段名直接获取数据，但是效率比较低，建议在字段前加上表名==

  ```
  --筛选出笛卡尔积中的正确数据
  --使用（表名.字段名）指明哪个表的字段
  select * from emp, dept where emp.deptno = dept.deptno;
  --可以给表使用别名
  select * from emp e, dept d where e.deptno = d.deptno;
  ```

  - 不等值连接：先做笛卡尔积，然后用不等值筛选

  ```
  --使用不等值筛选笛卡尔积中的正确数据
  select * from emp e, salgrade s where e.sal>s.losal and e.sal<s.hisal;
  ```

  - 自连接：自己和自己做笛卡尔积

  ```
  select e1.*, e2.* from emp e1, emp e2 where e1.mgr=e2.empno;
  ```

  - 外连接：在值缺少的时候使用

    - 左外连接：加在右边，显示左边对应字段没有值的数据

    ```
    --查询员工姓名、工作、薪资、部门名称及没有部门的员工信息
    select * from emp e, dept d where e.deptno=d.deptno(+);
    ```

    - 右外连接：加在左边，显示右边对应字段没有值的数据

    ```
    --查询员工姓名、工作、薪资、部门名称及没有员工的部门信息
    select * from emp e, dept d where e.deptno(+)=d.deptno;
    ```

## 12.2 SQL99方式

- 注意：

  - 依然给表添加别名；
  - 如果使用on或者using，必须使用inner join进行连接，inner可以省略；
  - 外连接outer关键字可以省略不写；
  - 依然可以使用分组、having、排序等；
  
- 笛卡尔积：使用cross join关键字

  ```
  select * from emp cross join dept;
  ```

- 筛选

  - 自然连接：先做一个笛卡尔积，然后按照所有的同名同值字段自动进行筛选；

    - 问题：1）不能按照部分字段名筛选；2）不能按照字段名不同，但值相同筛选；

    ```
    select * from emp natural join dept;
    ```

    - 解决1）：使用using关键字，必须是两表同名字段，可以多个

      ```
      select * from emp inner join dept using(deptno);
      ```

    - 解决2）：使用on关键字(可以等值或不等值)，普通筛选用where
    
      ```
      select * from emp inner join dept on emp.deptno=dept.deptno;
      ```

  - 外连接

    - 左外连接：select 内容 from 表名 left outer inner join 表名 on 条件；

      ```
      select * from emp e left inner join dept d on e.deptno=d.deptno;
      ```

    - 右外连接：select 内容 from 表名 right outer inner join 表名 on 条件；

      ```
      select * from emp e right inner join dept d on e.deptno=d.deptno;
      ```

    - 全外连接：select 内容 from 表名 full outer inner join 表名 on 条件；

      ```
      select * from emp e full outer inner join dept d on e.deptno=d.deptno;
      ```
    
  - 自连接：
  
    ```
    select e1.*,e2.ename from emp e1 inner join emp e2 on e1.mgr=e2.empno;
    ```

---

# 13 **三表联合查询**

## 13.1 SQL92实现

易语书写，**难于阅读**，语句结构不清晰

用法：

select 内容（别名，连接符，去除重复，函数，逻辑运算）

from（表名1，表名2...）

where 条件

group by 分组字段

having 多行函数筛选

order by 排序字段

```
--使用and作为条件连接
select * from emp e, dept d, city c where e.deptno=d.deptno and d.loc=c.cid;
```

## 13.2 SQL99实现

难于书写，**易于阅读**

用法：

select  内容 from 表名1

inner join 表名2

on 连接条件

 inner join 表名3

on 连接条件

where 普通筛选条件

group by 分组

having 多行函数筛选

order by 排序字段

```
--先两表inner join再和第三个表inner join
select * from emp e 
inner join dept d
on e.deptno=d.deptno
inner join city c
on d.loc=c.cid;
```

---

# **14 子查询**

（查询条件不明确，条件本身需要一次查询）

## 14.1 单行子查询：查询结果只有一个数据

where子句中允许出现查询语句，该查询语句称为**子查询**

***字符串区别大小写***

```
--查询所有比雇员‘CLARK’工资高的员工信息
select * from emp where sal>(select sal from emp where ename='CLARK');
--查询工资高于平均工资的员工姓名
select ename from emp where sal>(select avg(sal) from emp); 
--查询和scott属于同一部门且工资比他低的员工资料
select * from emp 
where deptno=(select deptno from emp where ename='SCOTT')
and sal<(select sal from emp where ename='SCOTT');
--查询工作和scott相同或者雇佣时间比scott早的员工
select * from emp
where job=(select job from emp where ename='SCOTT')
or hiredate<(select hiredate from emp where ename='SCOTT');
```

## 14.2 多行子查询

子查询的结果自由一个字段但是字段有n个值，使用关键字

- any 任意

  ```
  用法：select 内容 from 表名 where 字段名 比较运算符 any 子查询语句
  --查询工资高于任意一个CLERK的所有员工信息
  select * from emp
  where sal>any(select sal from emp where job='CLERK');
  ```

- all 所有

  ```
  用法：select 内容 from 表名 where 字段名 比较运算符 all 子查询语句
  --查询工资高于所有SALESMAN的员工信息
  select * from emp 
  where sal>all(select sal from emp where job='SALESMAN');
  ```

- in 任意在，相当于“=any”

- not in 任意不在

  ```
  用法：select 内容 from 表名 where 字段名 in 子查询语句
  --查询部门20中同部门10的雇员工作一样的雇员信息
  select * from emp 
  where job in (select job from emp where deptno=10) and deptno=20;
  ```

---

# 15 oracle账户管理

## 15.1 oracle自带账户

- system 管理账户

  特点：具备大部分操作权限，主要用来管理普通账户及oralce的数据

  使用人：oracle数据维护工作人员

- sys 超级管理员账户

  特点：具备system的所有权限，同时又具备其他权限

  使用人：oracle工程师

- 角色和权限
  - 角色：一系列权限的集合；
  - 权限：具备某类事物的操作能力；

## 15.2 创建账户

- 使用system账户，并使用dba身份，登录oracle管理系统（在plsql上）

- 创建用户

  ```
  --创建用户
  	--create user 用户名 identified by 密码
  	create user scott identified by csk123456;
  ```

## 15.3 维护账户

```
-- 给用户赋予权限
	-- 赋予数据库登录连接权限
	grant connect to scott;
	-- 赋予资源操纵权限
	grant resource to scott;
	
--赋予dba权限
grant dba to 账户名;

--可以查看其他用户的表，用用户名.表名
select * from scott.emp;

--删除权限
revoke 权限名 from 账户名;
```

## 15.4 删除账户

```
drop user 账户名;
```

---

# 16 oracle 二维表管理

## 16.1 创建表

### 16.1.1 创建简单表

使用：create table 表名（字段名 类型，字段名 类型，...）；

数据类型：

- number

  数值类型， number(a,b)：总长度为a，小数位长度为b，b可以不写，a不可以超过11；

- varchar2

  字符类型，varchar2(ln)：ln表示字符的最大长度，实际存储的大小是浮动的，但是ln表示的是上限；

  特点：动态分配存储空间，节省空间；

- char

  字符类型，char(ln)：不管真实数据长度多大，直接开辟ln大小存储数据；

  特点：存储效率高于varchar2；

- date

```
--创建表
create table student (
  --数字类型，括号内表示最多10位，不同字段逗号隔开
  sno number(10),
  --字符类型varchar2
  sname varchar2(100),
  sage number(3),
  ssex char(4),
  sfav varchar2(500),
  sbirth date，
  sqq varchar2(30)
);

--添加测试数据，注意日期的格式写对
insert into student values(1,'liuyan',18,'女','nothing','01-1月-1985');
```

### 16.1.2 约束创建

#### 1、主键约束

- 添加主键：非空唯一

  - 直接在创建表的字段后使用primary key

    ```
    create table student (
      sno number(10) primary key
    );
    ```

  - 在字段最后添加：constraints pk\_表名\_字段名 primary key(字段名)，这种方法可以自定义约束名（pk\_表名\_字段名）

    ```
    create table student (
      sno number(10),
      constraints pk_student_sno primary key(sno)
    );
    ```

  - 在创建表之后添加：alter table student add constraints pk\_表名\_字段名 primary key(字段名);

    ```
    create table student (
      sno number(10),
      constraints pk_student_sno primary key(sno)
    );
    alter table student add constraints ps_student_son primary key(sno);
    ```

- 删除主键

  ```
  --alter table 表名 drop constraints 主键约束名;
  alter table student drop constraints pk_student_sno;
  ```

#### 2、非空约束

- 设置值不为空

  - 直接在创建的字段后加：not null

    ```
    --在字段名后加not null
    create table student (
      sno number(10),
      sname varchar2(100) not null
    );
    ```

  - 在字段后面添加：constraints ck_表名\_字段名 check(字段名 is not null)

    ```
    --在所有的字段名后加
    create table student (
      sno number(10),
      sname varchar2(100),
      constraints ck_student_sname check(sname is not null)
    );
    ```

  - 在创建表之后加：alter table student add constraints ck_表名\_字段名 check(字段名 is not null)

    ```
    create table student (
      sno number(10),
      sname varchar2(100)
    );
    alter table student add constraints ck_student_sname check(sname is not null)
    ```

- 删除非空约束

  ```
  --alter table 表名 drop constraints 约束名;
  alter table student drop constraints ck_student_sname;
  ```

#### 3、检查约束

- 添加检查约束

  - 直接在字段后添加：使用check(检查条件)

    ```
    create table student (
      sno number(10),
      sname varchar2(100),
      sage number(3) check(sage>0 and sage<150),
      ssex char(4) check(ssex='男' or ssex='女')
    );
    ```

  - 在所有字段后添加

    ```
    create table student (
      sno number(10),
      sname varchar2(100),
      sage number(3),
      constraints ck_student_sage check(sage>0 and sage<150)
    );
    ```

  - 在创建表之后添加

    ```
    create table student (
      sno number(10),
      sname varchar2(100),
      sage number(3),
    );
    
    alter table student add constraints ck_student_sage check(sage<150 and sage>0);
    ```

- 删除检查约束

  ```
  alter table student drop constraints ck_student_sage;
  ```

#### 4、唯一约束

- 添加唯一约束

  - 直接在字段后加，使用unique关键字

    ```
    create table student (
      sno number(10),
      sname varchar2(100),
      sage number(3),
      sqq number(11) unique
    );
    ```

  - 在所有字段后加，constraints un_表名\_字段名 unique(字段名)

    ```
    create table student (
      sno number(10),
      sname varchar2(100),
      sage number(3),
      sqq number(11),
      constraints un_student_sqq unique(sqq)
    );
    ```

  - 在创建表之后加

    ```
    alter table student add constraints un_student_sqq unique(sqq);
    ```

- 删除唯一约束

  ```
  alter table student drop constraints un_student_sqq;
  ```

### 16.1.3 外键约束

​    （能不用外键，就不用外键）往当前表插入数据，插入数据的值是依赖于另一张表的。主动依赖的称为子表，被依赖的表称为父表，==外键加在子表里==。当在子表中插入的数据在父表中不存在，则会自动报错。

- 外键选取：一般选取父表的主键作为子表的外键；

- 外键缺点：

  - 无法直接删除父表信息，除非级联删除；

  - 级联删除：

    - 使用关键字on delete cascade，当删除父表数据时，自动将子表数据同时删除.缺点是无法保留历史数据；

    ```
    alter table student add constraints fk_student_cno foreign key(cno) references class(cno) on delete cascade;
    ```

    - 使用关键字on delete set null，当删除父表数据时，自动将子表数据依赖字段设为null，注意，**子表字段不能添加非空约束**；

    ```
    alter table student add constraints fk_student_cno foreign key(cno) references class(cno) on delete set null;
    ```

- 添加外键

  - 直接在字段之后加，使用：reference 表名(字段名)

    ```
    create table student(
      sno number(10) primary key,
      sname varchar2(100) not null,
      sage number(3) check(sage<150 and sage>0),
      ssex char(4) check(ssex='男' or ssex='女'),
      sfav varchar2(500),
      sqq varchar2(30) unique,
      cno number(10) reference class(cno)
    );
    ```

  - 在所有字段之后加，使用constraints fk_子表名\_字段名 foreign key(子表字段名) references 父表名(父表字段名) 

    ```
    create table student(
      sno number(10) primary key,
      sname varchar2(100) not null,
      sage number(3) check(sage<150 and sage>0),
      ssex char(4) check(ssex='男' or ssex='女'),
      sfav varchar2(500),
      sqq varchar2(30) unique,
      cno number(10),
      constraints fk_student_cno foreign key(cno) references class(cno) 
    );
    ```

  - 在创建表后添加，使用：alter table 子表名 add constraints fk_子表名\_子表字段名 foreign key(子表字段名) references 父表名(父表字段名)

    ```
    create table student(
      sno number(10) primary key,
      sname varchar2(100) not null,
      sage number(3) check(sage<150 and sage>0),
      ssex char(4) check(ssex='男' or ssex='女'),
      sfav varchar2(500),
      sqq varchar2(30) unique,
      cno number(10)
    );
    
    alter table student add constraints fk_student_cno foreign key(cno) references class(cno)
    ```

- 删除外键：alter table 子表名 drop constraints fk_子表名\_子表字段名;

## 16.2 维护表

### 16.2.1 添加新的字段

alter table 表名 add 字段名 类型

（一般不加非空约束）

```
alter table student add sphone number(11)
```

### 16.2.2 修改原有字段

- 修改字段名:alter table 表名 rename column 字段名 to 新字段名

  ```
  alter table student rename column sphone to phone
  ```

- 修改字段类型:alter table 表名 modify 字段名 类型;

  ```
  alter table student modify sphone varchar2(11);
  ```

- 删除字段：alter table 表名 drop column 字段名;

  ```
  alter table student drop column phone;
  ```

### 16.2.3 修改表名

```
rename student to student2;
```

## 16.3 删除表

```
--删除表：drop table 表名
drop table student
```

---

# 17 作业2（多表查询）

```
--列出所有雇员的姓名及其上级的姓名
select e1.ename,e2.ename from emp e1 
inner join emp e2 
on e1.mgr=e2.empno;

--列出部门名称和这些部门的雇员，同时列出那些没有雇员的部门，注意外连接没有inner
select * from emp e right join dept d on e.deptno=d.deptno;

--显示所有部门在“kaifeng”（dept loc, city cname）的员工的姓名
select e.ename from emp e 
inner join dept d 
on e.deptno=d.deptno
inner join city c
on d.loc=c.cid
where c.cname = 'kaifeng';

--显示员工"smith"的姓名,部门名称
select e.ename,d.dname from emp e
inner join dept d
on e.deptno=d.deptno
where e.ename='SMITH';

--显示员工姓名，部门名称，工资，工资级别（salgrade表grade字段），要求工资级别大于4级
select e.ename,d.dname,e.sal,s.grade from emp e
inner join dept d
on e.deptno=d.deptno
inner join salgrade s
on e.sal>s.losal and e.sal < s.hisal
where s.grade >4;

--显示员工'KING'和'FORD'管理的员工的姓名及其经理的姓名
select e1.ename,e2.ename,e3.ename from emp e1
inner join emp e2
on e1.mgr=e2.empno
left join emp e3
on e2.mgr=e3.empno
where e2.ename in ('KING', 'FORD');

--显示员工名，参加工作时间，经理名，参加工作时间：参加工作时间比经理早的
select e1.ename, e1.hiredate, e2.ename, e2.hiredate from emp e1
inner join emp e2
on e1.mgr=e2.empno
where e1.hiredate<e2.hiredate;

--求出部门名称中，带'S'字符的部门员工的工资总和、部门人数
select count(*),sum(sal) from emp e
inner join dept d
on e.deptno=d.deptno
where d.dname like '%S%' 
group by d.dname;

--列出所有员工的年工资，按年薪从低到高排序；
select ename,(sal+nvl(comm,0))*12 sal_year from emp order by sal_year;

--列出各种工作的最低工资以及从事此工作的雇员姓名
--select ename,job,sal from emp 
--where sal in (select min(sal) from emp group by job);
select * from emp e,(select min(sal) msal,job from emp group by job) s
where (e.job=s.job and e.sal=s.msal);

--列出所有部门的详细信息和部门人数
select * from dept d 
full join (select deptno,count(*) from emp group by deptno) s
on d.deptno=s.deptno;

--列出所有员工的姓名、部门名称和工资
select e.ename,e.sal,d.dname from emp e
inner join dept d
on e.deptno=d.deptno;

--查询员工信息：员工姓名，老板名字
select * from emp e
natural join (select ename boss from emp where mgr is null);

--要求查询出每一个雇员的编号、姓名、工资、部门名称、工资等级
select e.*, s.grade from emp e
inner join salgrade s
on (sal>losal and sal<hisal);

--按照职位分组，求出每个职位的最高工资、最低工资和平均工资
select job,avg(sal), max(sal), min(sal) from emp group by job;

--统计平均工资大于2000的部门的详细信息
select * from dept d 
inner join (select deptno,avg(sal) from emp group by deptno having avg(sal)>2000) s
on d.deptno=s.deptno; 
```

---

# 18 oracle的序列&视图&索引

## 18.1序列

- 创建序列：create sequence 序列名

  1、默认开始没有值；

  2、序列名.nextval每次执行都会自增一次，默认步长为1

  3、序列名.currval查看当前序列值，开始没有值的

  作用：作为主键使用，动态获取值，避免主键冲突

  注意：主键是非空唯一，并不一定要连续

  ```
  --创建序列
  create sequence cc;
  --查看当前值
  select cc.currval from dual;
  --查看下一个值
  select cc.nextval from dual;
  ```

  ```
  --作为主键使用
  create sequence c1;
  create table teacher(
    tid number(11) primary key,
    tname varchar2(100) not null
  );
  insert into teacher values(c1.nextval, 'zhangsan');
  ```

  4、创建自定义序列

  ```
  create sequence aa
  start with 5
  increment by 2
  max 1000; --最大到1000
  ```

- 删除序列

  ```
  drop sequence aa;
  ```

## 18.2 索引

- 作用：提升查询效率

- 使用索引：

  create index 索引名 on 表名(字段名)

  ```
  create index index_teacher_tname on teacher(tname);
  ```

- 删除索引：drop index 索引名

  ```
  drop index index_teacher_tname;
  ```

- 特点：

  - 会默认给主键创建索引目录；
  - 显式创建、隐式执行；

## 18.3 视图

创建视图必须有dba权限

- 创建视图：create view 视图名 as select 对外提供的字段名 from 真实表名

  ```
  create view stu as select sno,sname,sage from student;
  
  --开启只读模式
  create view stu as select sno,sname,sage from student with read only;
  ```

- 删除视图：drop view 视图名

  ```
  drop view stu;
  ```

- 特点

  - 保护真实表，隐藏核心字段；
  - 对视图中表的操作也会在映射执行到真实表中；
  - 可以手动开启只读模式，使用with read only；

# 19 分页查询

当一个表中数据量特别大，如果一次性给用户将造成页面过于庞大，因此使用分页查询

- 使用roenum关键字，对查询结果进行编号，rownum只能做小于操作，不能做大于操作

  ```
  select rownum, e.* from emp e;
  --查询员工信息的前5条信息
  select rownum, e.* from emp e where rownum<=5;
  --查询员工信息的6-10条
  select * from (select rownum r,e.* from emp e where r<=10) t where r>5;
  --分页规律总结：每页显示m条数据，查询第n页
  select * from (select rownum r,e.* from emp e where r<=m*n) t where r>m*(n-1);
  
  --分页查询员工信息按照工资排序，先排序
  select t.* from (select rownum r,e.* 
  from (select * from emp order by sal) e 
  where rownum<=10) t where r>5;
  ```

# 20 MySQL介绍和安装

开放源码的轻量型数据库管理系统，使用简单快捷。

- 自带四个库
  - mysql
  - performance_schema
  - test
  - information_schema

- root的密码就用root

- 卸载
  1. 在控制面板中卸载
  2. 删除安装文件夹
  3. 删除C盘下隐藏文件夹programData中的mysql文件夹
  4. 清理垃圾（注册表）
- 测试安装
  - 打开navicate（点击connection）
  - 输入连接名（英文）
  - 输入用户名（root）
  - 输入密码，点击测试连接

# 21 MySQL使用

注释是##

## 21.1 创建数据库

1. 任意双击打开一个数据库，新建一个SQL窗口

2. 使用命令

   ```
   ##create database 库名 default character set utf8;
   create database kk default character set utf8;
   
   ##切换到新建库：use 库名
   use kk;
   ```

使用图形界面可以直接右键链接名

删除数据库：drop database 库名；

## 21.2 创建表

### 21.2.1 创建表语句

```
##创建学生表
create table student(
	sid int(10) not null auto_increment primary key,
	sname varchar(100) not null,
	sage int(4),
	ssex char(4),
	sbirth date
)

##添加数据
insert into student values(default,'zhangsan',18,'男','1990-2-1');

##添加字段
alter table student add money float;
```

注意：mysql没有序列，但是可以在创建表的时候指定主键是自增的，使用关键字auto_increment。

### 21.2.2 常见字段类型

- 数值类型
  - int（长度） 表示整数类型的数据 长度可以指定，不能超过10
  - float/double  表示浮点数
- 字符类型
  - varchar（长度） 动态分配存储长度
  - char（长度）  分配固定长度
- 日期类型
  - date   格式为yyyy-mm-dd
  - datetime  格式为yyyy-MM-dd hh:mm:ss 长度占8个字节
  - timestamp  格式同上，会自动进行时区转换，占用4个字节
  - time  时间
  - year  年份
- 其他类型

  - TEXT  字符数据
  - BLOB  二进制数据

### 21.2.3 约束

#### 21.2.3.1 主键约束

- 在创建表时，在字段后，使用primary key；
- 在创建表时，在所有字段后，使用（两种方式）
  - primary key（字段名）
  - constraint 约束名 primary key(字段名);  注意是constraint，不是constraints
- 创建表后，alter table 表名 add constraint 约束名 primary key(字段名);

#### 21.2.3.1 非空约束

- 在创建表时，在字段后，使用not null；

- 在创建表后，使用alter table 表名 modify 字段名 类型 not null;

  ```
  alter table class modify cname varchar(100) not null;
  ```

  

注意：mysql中非空约束的空字符是可以存储进去的，即‘’是可以存进去，但null不可以存。

#### 21.2.3.1 检查约束

mysql中没有检查约束，但使用check关键字又不会报错。

解决办法：

- 使用代码逻辑进行数据的过滤；
- 使用mysql的存储过程（就是自定义函数）;

#### 21.2.3.1 唯一约束

- 在创建表时，在字段名后，直接加unique；
- 在创建表时，在所有字段后，constraint 约束名 unique key(字段名);
- 创建表后，alter table 表名 add constraint 约束名 unique key(字段名);

#### 21.2.3.1 外键约束

- 在创建表时，在字段名后加，references 父表名(父表字段名)；
- 在创建表时，在所有字段后加，constraint 约束名 foreign key(字段名) references 父表名(父表字段名);
- 在创建表后加，alter table 表名 add constraint 约束名 foreign key(字段名) references 父表名(父表字段名) on delete cascade on update cascade;**加了级联删除**

### 21.2.4 表的修改删除

- 添加字段

  alter table 表名 add 字段名 类型；

- 删除字段

  alter table 表名 drop 字段名;

- 修改字段类型

  alter table 表名 modify 字段名 类型;

- 修改字段名

  alter table 表名 change 字段名 新字段名 类型;

- 修改表名

  alter table 表名 rename as 新的表名

- 删除表

  drop table 表名

## 21.3 操作表数据

- 显示当前所有表：show tables
- 显示数据库：show databases
- 增删改查（和orcale大部分一样）
  - 连接符：使用concat(字段名，字段名/字符串)

## 21.4 分页

使用关键字limit，每页显示n条，查询m页：select * from 表名 limit (m-1)*n,n

```
##一页显示2条数据
select * from student limit 0,2;
select * from student limit 2,2;
```



## 21.5 数据库备份

- 导入

  - mysql>source 路径
  - mysql -u root -p 数据库名 < dbname.sql

- 导出

  - 导出整个数据库

    mysqldump -u root -p 数据库名>dbname.sql

  - 只导出一个表

    mysqldump -u root -p 数据库名 表名>dbname.sql

#  22 PowerDesigner

## 22.1 进行数据库设计

1. 使用管理员身份运行程序
2. 创建数据库物理模型
3. 在工作空间中设计表
4. 创建表之间的关系连接
5. 将物理模型导出为sql脚本文件，在数据库中执行

## 22.2 物理模型反转

将数据库中现有的表转换为pdm文件

1. file  -》reverse engineer -》 database
2. 配置需要反转的数据库
3. 使用配置好的数据源进行数据库文件的反转



# 23 JDBC

java获取数据的方式：1、声明赋值；2、控制台输入；3、IO流；4、socket+io；5、从数据库获取；

## 23.1 概念

数据库厂商对外提供java支持的数据库操作的驱动包，也就是jar文件。jar里面是class文件，没源码。

## 23.2 使用

### 23.2.1 新增

```
/**
 * 常见的JDBC错误
 * 1 ClassNotFoundException：驱动类未找到
 * 2 java.sql.SQLException:URL错误、数据库用户名等错误
 * 3 SQLSyntaxErrorException:SQL语句错误
 */
public class TestInsert {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		// 1 加载驱动类,ojdbc5,ojdbc6可以不用加载
		//Class.forName("oracle.jdbc.driver.OracleDriver");
		// 2 获取数据库连接对象(连接指定的数据库)
		//Connection conn = DriverManager.getConnection(url, user, password);
		Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:XE", "scott", "csk123456");
		// 3 获取sql命令对象(编译并发送sql命令)
		Statement stmt = conn.createStatement();
		// 4 创建sql命令,不能加分号
		String sql = "insert into dept values(60, 'kangkang', '8')";
		// 5 执行sql命令
		int i = stmt.executeUpdate(sql);//未成功返回-1,成功返回更改了的数据条数
		System.out.println(i);
		// 6 关闭资源
		stmt.close();
		conn.close();
	}
}

//写法二
public class TestInsert2 {
	public static void main(String[] args) {
		Connection conn = null;
		Statement stmt = null;
		String driver = "oracle.jdbc.driver.OracleDriver";
		String url = "jdbc:oracle:thin:@localhost:1521:XE";
		String username = "scott";
		String password = "csk123456";
		try {
			// 1 加载驱动类,ojdbc5,ojdbc6可以不用加载
			Class.forName(driver);
			// 2 获取数据库连接对象(连接指定的数据库)
			//Connection conn = DriverManager.getConnection(url, user, password);
			conn = DriverManager.getConnection(url, username, password);
			// 3 获取sql命令对象(编译并发送sql命令)
			stmt = conn.createStatement();
			// 4 创建sql命令,不能加分号
			String sql = "insert into dept values(60, 'kangkang', '8')";
			// 5 执行sql命令
			int i = stmt.executeUpdate(sql);//未成功返回-1,成功返回更改了的数据条数
			System.out.println(i);
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			// 6 关闭资源
			try {
				stmt.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			try {
				conn.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
```

### 23.2.2 修改

```
/*流程不变，sql语句改一下*/
public class TestUpdate {
	public static void main(String[] args) {
		Connection conn = null;
		Statement stat = null;
		String driver = "oracle.jdbc.driver.OracleDriver";
		String url = "jdbc:oracle:thin:@localhost:1521:XE";
		String username = "scott";
		String password = "csk123456";
		//1 加载驱动
		try {
			Class.forName(driver);
			//2 创建连接对象
			conn = DriverManager.getConnection(url, username, password);
			//3 创建声明对象
			stat = conn.createStatement();
			//4 创建sql语句
			String sql = "update dept set dname='chen' where deptno='50'";
			//5 执行sql命令
			int i = stat.executeUpdate(sql);
			System.out.println(i);
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			//6 关闭资源
			try {
				conn.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			try {
				stat.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
```

### 23.2.3 删除

流程不变，改下sql语句

### 23.2.4 事务

一个事件的完成需要几个子操作的联合完成，只要有一个失败，则回滚到原始状态

JDBC中的事务是自动提交的，需要设置JDBC的事务是手动提交

解决在业务处理过程中，某条SQL语句执行失败，但数据已经被更改的问题

```
public class TestTran {
	public static void main(String[] args) {
		Connection conn = null;
		Statement stat = null;
		String driver = "oracle.jdbc.driver.OracleDriver";
		String url = "jdbc:oracle:thin:@localhost:1521:XE";
		String username = "scott";
		String password = "csk123456";
		//1 加载驱动
		try {
			Class.forName(driver);
			//2 创建连接对象
			conn = DriverManager.getConnection(url, username, password);
			//设置事务为手动提交
			conn.setAutoCommit(false);
			//3 创建声明对象
			stat = conn.createStatement();
			//4 创建sql语句
			String sql = "update dept set dname='chen' where deptno='100'";
			//5 执行sql命令
			try {
				int i = stat.executeUpdate(sql);
				System.out.println(i);
				conn.commit();
			} catch (Exception e) {
				conn.rollback();
			}
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			//6 关闭资源
			try {
				conn.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			try {
				stat.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
```

### 23.2.5 查询

```
/*
 * 查询
 * 查询返回的是ResultSet,不方便操作,一般需要转成ArrayList
 * */
public class TestSelect {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		ArrayList<Dept> dept = DeptDaoImpl.getDeptInfo();
		//打印结果
		System.out.println(dept.get(1));
	}
}

//查
	public static ArrayList<Dept> getDeptInfo () throws ClassNotFoundException, SQLException {
		//声明ArrayList
		ArrayList<Dept> dept = new ArrayList<>();
		//声明所需的字符串
		String driver = "oracle.jdbc.driver.OracleDriver";
		String url = "jdbc:oracle:thin:@localhost:1521:XE";
		String user = "scott";
		String password = "csk123456";
		//加载驱动类
		Class.forName(driver);
		//创建连接对象
		Connection conn = DriverManager.getConnection(url, user, password);
		//创建声明对象
		Statement stmt = conn.createStatement();
		//sql命令
		String sql = "select * from dept";
		//执行sql命令
		ResultSet rs = stmt.executeQuery(sql);
		//将ResultSet转换为ArrayList
		while(rs.next()) {
			Dept dp = new Dept();
			dp.setDeptno(rs.getInt("deptno"));
			dp.setDname(rs.getString("dname"));
			dp.setLoc(rs.getInt("loc"));
			dept.add(dp);
		}
		return dept;
	}
```

### 23.2.6 复习

开发步骤：

1. 业务需求分析
2. 数据库设计
3. sql语句设计
4. 数据库操作功能类实现
5. 业务逻辑代码实现
6. 联合测试
7. 上线测试
8. 维护

==**封装的思想：相同的保留，不同的传参**==



### 23.2.6 MVC思想

